<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/astnode.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/astnode.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// TODO: docs
'use strict';

var Syntax = require('jsdoc/src/syntax').Syntax;
var util = require('util');

// Counter for generating unique node IDs.
var uid = 100000000;

/**
 * Check whether an AST node represents a function.
 *
 * @param {Object} node - The AST node to check.
 * @return {boolean} Set to `true` if the node is a function or `false` in all other cases.
 */
var isFunction = exports.isFunction = function(node) {
    return node.type === Syntax.FunctionDeclaration || node.type === Syntax.FunctionExpression;
};

/**
 * Check whether an AST node creates a new scope.
 *
 * @param {Object} node - The AST node to check.
 * @return {Boolean} Set to `true` if the node creates a new scope, or `false` in all other cases.
 */
var isScope = exports.isScope = function(node) {
    // TODO: handle blocks with "let" declarations
    return !!node &amp;&amp; typeof node === 'object' &amp;&amp; ( node.type === Syntax.CatchClause ||
        isFunction(node) );
};

// TODO: docs
var addNodeProperties = exports.addNodeProperties = function(node) {
    var debugEnabled = !!global.env.opts.debug;
    var newProperties = {};

    if (!node || typeof node !== 'object') {
        return null;
    }

    if (!node.nodeId) {
        newProperties.nodeId = {
            value: 'astnode' + uid++,
            enumerable: debugEnabled
        };
    }

    if (!node.parent &amp;&amp; node.parent !== null) {
        newProperties.parent = {
            // `null` means 'no parent', so use `undefined` for now
            value: undefined,
            writable: true
        };
    }

    if (!node.enclosingScope &amp;&amp; node.enclosingScope !== null) {
        newProperties.enclosingScope = {
            // `null` means 'no enclosing scope', so use `undefined` for now
            value: undefined,
            writable: true
        };
    }

    if (debugEnabled &amp;&amp; !node.parentId) {
        newProperties.parentId = {
            enumerable: true,
            get: function() {
                return this.parent ? this.parent.nodeId : null;
            }
        };
    }

    if (debugEnabled &amp;&amp; !node.enclosingScopeId) {
        newProperties.enclosingScopeId = {
            enumerable: true,
            get: function() {
                return this.enclosingScope ? this.enclosingScope.nodeId : null;
            }
        };
    }

    Object.defineProperties(node, newProperties);

    return node;
};

// TODO: docs
var nodeToString = exports.nodeToString = function(node) {
    var tempObject;

    var str = '';

    switch (node.type) {
        case Syntax.ArrayExpression:
            tempObject = [];
            node.elements.forEach(function(el, i) {
                // handle sparse arrays. use `null` to represent missing values, consistent with
                // JSON.stringify([,]).
                if (!el) {
                    tempObject[i] = null;
                }
                // preserve literal values so that the JSON form shows the correct type
                else if (el.type === Syntax.Literal) {
                    tempObject[i] = el.value;
                }
                else {
                    tempObject[i] = nodeToString(el);
                }
            });

            str = JSON.stringify(tempObject);
            break;

        case Syntax.AssignmentExpression:
            str = nodeToString(node.left);
            break;

        case Syntax.FunctionDeclaration:
            // falls through

        case Syntax.FunctionExpression:
            str = 'function';
            break;

        case Syntax.Identifier:
            str = node.name;
            break;

        case Syntax.Literal:
            str = String(node.value);
            break;

        case Syntax.MemberExpression:
            // could be computed (like foo['bar']) or not (like foo.bar)
            str = nodeToString(node.object);
            if (node.computed) {
                str += util.format('[%s]', node.property.raw);
            }
            else {
                str += '.' + nodeToString(node.property);
            }
            break;

        case Syntax.ObjectExpression:
            tempObject = {};
            node.properties.forEach(function(prop) {
                var key = prop.key.name;
                // preserve literal values so that the JSON form shows the correct type
                if (prop.value.type === Syntax.Literal) {
                    tempObject[key] = prop.value.value;
                }
                else {
                    tempObject[key] = nodeToString(prop);
                }
            });

            str = JSON.stringify(tempObject);
            break;

        case Syntax.ThisExpression:
            str = 'this';
            break;

        case Syntax.UnaryExpression:
            // like -1. in theory, operator can be prefix or postfix. in practice, any value with a
            // valid postfix operator (such as -- or ++) is not a UnaryExpression.
            str = nodeToString(node.argument);

            // workaround for https://code.google.com/p/esprima/issues/detail?id=526
            if (node.prefix === true || node.prefix === undefined) {
                str = node.operator + str;
            }
            else {
                // this shouldn't happen
                throw new Error( util.format('Found a UnaryExpression with a postfix operator: %j',
                    node) );
            }
            break;

        case Syntax.VariableDeclarator:
            str = nodeToString(node.id);
            break;

        default:
            str = '';
    }

    return str;
};

// TODO: docs
var getParamNames = exports.getParamNames = function(node) {
    if (!node || !node.params) {
        return [];
    }

    return node.params.map(function(param) {
        return nodeToString(param);
    });
};

// TODO: docs
var isAccessor = exports.isAccessor = function(node) {
    return !!node &amp;&amp; typeof node === 'object' &amp;&amp; node.type === Syntax.Property &amp;&amp;
        (node.kind === 'get' || node.kind === 'set');
};

// TODO: docs
var isAssignment = exports.isAssignment = function(node) {
    return !!node &amp;&amp; typeof node === 'object' &amp;&amp; (node.type === Syntax.AssignmentExpression ||
        node.type === Syntax.VariableDeclarator);
};

// TODO: docs
/**
 * Retrieve information about the node, including its name and type.
 */
var getInfo = exports.getInfo = function(node) {
    var info = {};

    switch (node.type) {
        // like: "foo = 'bar'" (after declaring foo)
        // like: "MyClass.prototype.myMethod = function() {}" (after declaring MyClass)
        case Syntax.AssignmentExpression:
            info.node = node.right;
            info.name = nodeToString(node.left);
            info.type = info.node.type;
            info.value = nodeToString(info.node);
            // if the assigned value is a function, we need to capture the parameter names here
            info.paramnames = getParamNames(node.right);
            break;

        // like: "function foo() {}"
        case Syntax.FunctionDeclaration:
            info.node = node;
            info.name = nodeToString(node.id);
            info.type = info.node.type;
            info.paramnames = getParamNames(node);
            break;

        // like the function in: "var foo = function() {}"
        case Syntax.FunctionExpression:
            info.node = node;
            // TODO: should we add a name for, e.g., "var foo = function bar() {}"?
            info.name = '';
            info.type = info.node.type;
            info.paramnames = getParamNames(node);
            break;

        // like the param "bar" in: "function foo(bar) {}"
        case Syntax.Identifier:
            info.node = node;
            info.name = nodeToString(info.node);
            info.type = info.node.type;
            break;

        // like "a.b.c"
        case Syntax.MemberExpression:
            info.node = node;
            info.name = nodeToString(info.node);
            info.type = info.node.type;
            break;

        // like "a: 0" in "var foo = {a: 0}"
        case Syntax.Property:
            info.node = node.value;
            info.name = nodeToString(node.key);
            info.value = nodeToString(info.node);

            if ( isAccessor(node) ) {
                info.type = nodeToString(info.node);
                info.paramnames = getParamNames(info.node);
            }
            else {
                info.type = info.node.type;
            }

            break;

        // like: "var i = 0" (has init property)
        // like: "var i" (no init property)
        case Syntax.VariableDeclarator:
            info.node = node.init || node.id;
            info.name = node.id.name;

            if (node.init) {
                info.type = info.node.type;
                info.value = nodeToString(info.node);
            }

            break;

        default:
            info.node = node;
            info.type = info.node.type;
    }

    return info;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-jsdoc_borrow.html">jsdoc/borrow</a></li><li><a href="module-jsdoc_config.html">jsdoc/config</a></li><li><a href="module-jsdoc_doclet.html">jsdoc/doclet</a></li><li><a href="module-jsdoc_fs.html">jsdoc/fs</a></li><li><a href="module-jsdoc_name.html">jsdoc/name</a></li><li><a href="module-jsdoc_opts_argparser.html">jsdoc/opts/argparser</a></li><li><a href="module-jsdoc_opts_args.html">jsdoc/opts/args</a></li><li><a href="module-jsdoc_package.html">jsdoc/package</a></li><li><a href="module-jsdoc_path.html">jsdoc/path</a></li><li><a href="module-jsdoc_plugins.html">jsdoc/plugins</a></li><li><a href="module-jsdoc_readme.html">jsdoc/readme</a></li><li><a href="module-jsdoc_src_filter.html">jsdoc/src/filter</a></li><li><a href="module-jsdoc_src_handlers.html">jsdoc/src/handlers</a></li><li><a href="module-jsdoc_src_parser.html">jsdoc/src/parser</a></li><li><a href="module-jsdoc_src_scanner.html">jsdoc/src/scanner</a></li><li><a href="module-jsdoc_src_visitor.html">jsdoc/src/visitor</a></li><li><a href="module-jsdoc_src_walker.html">jsdoc/src/walker</a></li><li><a href="module-jsdoc_tag.html">jsdoc/tag</a></li><li><a href="module-jsdoc_tag_dictionary.html">jsdoc/tag/dictionary</a></li><li><a href="module-jsdoc_tag_dictionary_definitions.html">jsdoc/tag/dictionary/definitions</a></li><li><a href="module-jsdoc_tag_inline.html">jsdoc/tag/inline</a></li><li><a href="module-jsdoc_tag_type.html">jsdoc/tag/type</a></li><li><a href="module-jsdoc_tag_validator.html">jsdoc/tag/validator</a></li><li><a href="module-jsdoc_template.html">jsdoc/template</a></li><li><a href="module-jsdoc_tutorial.html">jsdoc/tutorial</a></li><li><a href="module-jsdoc_tutorial_resolver.html">jsdoc/tutorial/resolver</a></li><li><a href="module-jsdoc_util_dumper.html">jsdoc/util/dumper</a></li><li><a href="module-jsdoc_util_error.html">jsdoc/util/error</a></li><li><a href="module-jsdoc_util_logger.html">jsdoc/util/logger</a></li><li><a href="module-jsdoc_util_markdown.html">jsdoc/util/markdown</a></li><li><a href="module-jsdoc_util_templateHelper.html">jsdoc/util/templateHelper</a></li></ul><h3>Classes</h3><ul><li><a href="module-jsdoc_config-Config.html">Config</a></li><li><a href="module-jsdoc_doclet-Doclet.html">Doclet</a></li><li><a href="module-jsdoc_package.Package.html">Package</a></li><li><a href="module-jsdoc_readme-ReadMe.html">ReadMe</a></li><li><a href="module-jsdoc_src_filter.Filter.html">Filter</a></li><li><a href="module-jsdoc_src_parser.Parser.html">Parser</a></li><li><a href="module-jsdoc_src_scanner.Scanner.html">Scanner</a></li><li><a href="module-jsdoc_tag_dictionary.Dictionary.html">Dictionary</a></li><li><a href="module-jsdoc_tag-Tag.html">Tag</a></li><li><a href="module-jsdoc_template.Template.html">Template</a></li><li><a href="module-jsdoc_tutorial.Tutorial.html">Tutorial</a></li></ul><h3>Events</h3><ul><li><a href="module-jsdoc_src_parser.Parser.html#event:jsdocCommentFound">jsdocCommentFound</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-jsdoc_doclet-Doclet_meta.html">meta</a></li><li><a href="module-jsdoc_doclet-Doclet_meta.code.html">code</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getInfo">getInfo</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isScope">isScope</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha10</a> on Mon Nov 10 2014 14:21:44 GMT+0900 (JST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
